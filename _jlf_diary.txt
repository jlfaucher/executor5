ooRexx5 has too many changes, compared to ooRexx4.
Not possible to merge the changes for ooRexx5 into the Github repository Executor.
Hence the creation of a new Github repository Executor5...


===============================================================================
2015 aug 03

Continue working on the build error "sized deallocation..."

https://en.wikipedia.org/wiki/Placement_syntax

http://en.cppreference.com/w/cpp/memory/new/operator_new
    In section "Global replacements"
        The placement form void* operator new(size_t, size_t) is not allowed
        because the matching signature of the deallocation function,
        void operator delete(void*, size_t), is a usual (not placement) deallocation function.

http://en.cppreference.com/w/cpp/memory/new/operator_delete
    In section "replaceable deallocation functions":
        void operator delete  ( void* ptr, std::size_t sz );    (5)	(since C++14)
        void operator delete[]( void* ptr, std::size_t sz );    (6)	(since C++14)
        void operator delete  ( void* ptr, std::size_t sz, const std::nothrow_t& tag ); (7) (since C++14) (until C++17)
        void operator delete[]( void* ptr, std::size_t sz, const std::nothrow_t& tag ); (8) (since C++14) (until C++17)

        JLF : this comment is incomprehensible
        5-8) Called instead of (1-4) if a user-defined replacement is provided
        except that it's implementation-defined whether (1-4) or (5-8) is called
        when deleting objects of incomplete type and arrays of non-class and
        trivially-destructible class types (since C++17).
        The standard library implementations are identical to (1-4).

    In section "class-specific deallocation functions":
        void T::operator delete  ( void* ptr, std::size_t sz ); (15)
        void T::operator delete[]( void* ptr, std::size_t sz ); (16)
        15) If defined, and if (13) is not defined, called by the usual single-object delete-expressions if deallocating an object of type T.
        16) If defined, and if (14) is not defined, called by the usual array delete[]-expressions if deallocating an array of objects of type T.

https://isocpp.org/files/papers/n3778.html
    3.7.4.2
    The global operator delete with exactly two parameters, the second of which has
    type std::size_t, is a usual deallocation function.
    The global operator delete[] with exactly two parameters, the second of which has
    type std::size_t, is a usual deallocation function.
    [Footnote: This deallocation function precludes use of an allocation function
    void operator new(std::size_t, std::size_t) as a placement allocation function
    (C.?.? [diff.cpp11.basic]). —end footnote]

    In C++ 2011, one could declare a global placement allocation function and deallocation function as follows.
        void operator new(std::size_t, std::size_t);
        void operator delete(void*, std::size_t) noexcept;
    Now, however, the declaration of operator delete might match a predefined usual (non-placement) operator delete (3.7.4 [basic.stc.dynamic]).
    If so, the program is ill-formed, as it was for class member allocation functions and deallocation functions (5.3.4 [new.expr])

http://www.cplusplus.com/reference/new/operator%20delete/
    ordinary (1)            void operator delete (void* ptr) noexcept;
    nothrow (2)             void operator delete (void* ptr, const std::nothrow_t& nothrow_constant) noexcept;
    placement (3)           void operator delete (void* ptr, void* voidptr2) noexcept;
    with size (4)           void operator delete (void* ptr, std::size_t size) noexcept;
    nothrow with size (5)   void operator delete (void* ptr, std::size_t size, const std::nothrow_t& nothrow_constant) noexcept;
    Note that if one of the signatures with size is replaced, its corresponsing
    version without size shall also be replaced (and the other way around).
    I.e.: If either (1) or (4) is replaced, both shall be replaced.
    Likewise, if either (2) or (5) is replaced, both shall be replaced.

--> The solution is to add a parameter to the operator new function.
void *operator new(size_t base, size_t entries, bool placement=true);

Other build errors fixed.
Now build 100% with Visual Studio 2015 Community.


===============================================================================
2015 aug 02

Building with Visual Studio 2015 Community (cl 19.00.23026).

ClientMessage.cpp
C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\INCLUDE\stdint.h(17):
error C2371: 'int8_t': redefinition; different basic types
main\trunk\api\platform\windows\rexxapitypes.h(70): note: see declaration of 'int8_t'
...
and several others.
--> fixed by modifying CMakeLists.txt to have these checks under WIN32 too :
check_include_file(inttypes.h HAVE_INTTYPES_H)
check_include_file(stdint.h HAVE_STDINT_H)
and then including config.h in api\platform\windows\rexxapitypes.h
and testing HAVE_INTTYPES_H to let include inttypes.h (from Windows Kits\10) which includes stdint.h


main\trunk\interpreter\classes\ArrayClass.cpp(123):
error C2956: sized deallocation function 'operator delete(void*, size_t)' would be chosen as placement deallocation function.
predefined C++ types (compiler internal)(30): note: see declaration of 'operator delete'
https://llvm.org/bugs/show_bug.cgi?id=23513
https://connect.microsoft.com/VisualStudio/feedback/details/1351894
http://stackoverflow.com/questions/5367674/what-does-the-error-non-placement-deallocation-function
    One of the answers refers to this bug of ooRexx : https://sourceforge.net/p/oorexx/bugs/905/
    The fix was in commit 6218.
    Modified files :
        ExpressionLogical.hpp · /main/trunk/interpreter/expression
        ExpressionMessage.hpp · /main/trunk/interpreter/expression
        NumberStringClass.hpp · /main/trunk/interpreter/classes
        RexxBehaviour.hpp · /main/trunk/interpreter/behaviour
        RexxListTable.hpp · /main/trunk/interpreter/classes/support
        StackClass.hpp · /main/trunk/interpreter/classes

JLF : review history of RexxBehaviour.hpp (one of the files impacted by the commit 6218)
    before 6218
        void *operator new(size_t, size_t);
        inline void *operator new(size_t size, void *ptr) {return ptr;};
        inline void  operator delete(void *) { ; }
        inline void  operator delete(void *, void *) { ; }
    6218 : add
        inline void  operator delete(void *, size_t) { }
    10289 : remove
        inline void  operator delete(void *) { ; }
    10400 : remove
        inline void *operator new(size_t size, void *ptr) {return ptr;};
        inline void  operator delete(void *, void *) { ; }
    10469 : remove the 2nd arg size_t
        before: inline void  operator delete(void *, size_t) { }
        after:  inline void  operator delete(void *) { }
    10540 : remove
        void *operator new(size_t, size_t);
        inline void  operator delete(void *) { }

--> Current build error not yet fixed.


===============================================================================
2014 nov 11

Creation of the Github repository Executor5.
Procedure :
Using SmartGit, clone svn://svn.code.sf.net/p/oorexx/code-0/main (svn)
Add the remote git@github.com:jlfaucher/executor5.git (origin)
Push svn to origin

Remember, don't use
svn+ssh://jfaucher@svn.code.sf.net/p/oorexx/code-0/main
to avoid any accidental update of SVN repository.


2015 apr 26
Attempt to reclone because the history of revisions has a "hole" before rev 10464 "promote sandbox version to trunk".
But... see below, does not work.
Not a big problem, I can stay like that.
I keep the procedure, for the records.

Follow the procedure described here :
https://www.syntevo.com/smartgit/howtos/5/show?page=config.svn-clone-custom-branch-layout
because ooRexx SVN repository has not a standard branch layout.
Repository, Clone.
Check the box "Just initialize clone".
Click finish.
-->  The repository is in state <incomplete>
Close the repository.
Edit the file .git/svn/.svngit/svngitkit.config
Replace the section [svn-git-remote "svn"] by :
[svn-git-remote "svn"]
	url = svn://svn.code.sf.net/p/oorexx/code-0/main/trunk
	fetch = trunk:refs/remotes/svn/trunk
    branches = branches/*:refs/remotes/svn/branches/*
    tags = releases/*:refs/remotes/svn/releases/*
    additional-branches = "sandbox/rick/*:refs/remotes/sandbox/rick/*"
[svn-git-remote "svn"]
	url = svn://svn.code.sf.net/p/oorexx/code-0/main
	fetch = trunk:refs/remotes/svn/trunk
	branches = branches/*:refs/remotes/svn/branches/*
	tags = releases/*:refs/remotes/svn/releases/*
Reopen the repository in SmartGit.
Remote, Pull, Fetch only (rebase).
--> Display "Fetch".
When done, the repository is still in state <incomplete>.
Again : Remote, pull
--> Display "Restarting clone", and work in background (you see the progression in the bottom bar).
and... BOOM !
Repository is inconsistent (remote reference "refs/remotes/svn/branches/4.1 corresponds to SVN
remote "svn", but has no fetched SVN commit).
Please reclone the repository from scratch.

===============================================================================
History of merges.

rev 10688
