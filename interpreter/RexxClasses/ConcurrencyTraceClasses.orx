/****
Description :
    Convert a trace to an annotated trace.

    The expected input format is something like that (in case of 32-bit pointers) :
    0000f5fc 7efb0180 7eeee7a0 00000         >I> Routine D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
    0000f5fc 7efb0180 7eeee7a0 00000         >I> Routine A_ROUTINE in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
    0000f5fc 7efb29f8 7eeee7a0 00001*        >I> Method INIT with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
    0000f5fc 7efb29f8 7eeee7a0 00001*     44 *-* self~table = .IdentityTable~new
    00010244 00000000 00000000 00000  Error 99 running D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\trace\doit.rex line 17:  Translation error
    00010244 00000000 00000000 00000  Error 99.916:  Unrecognized directive instruction

    See RexxActivity::traceOutput
    Utilities::snprintf(buffer, sizeof buffer - 1, CONCURRENCY_TRACE,
                                                   Utilities::currentThreadId(),
                                                   activation,
                                                   (activation) ? activation->getVariableDictionary() : NULL,
                                                   (activation) ? activation->getReserveCount() : 0,
                                                   (activation && activation->isObjectScopeLocked()) ? '*' : ' ');

    The same format with 64-bit pointers is also supported.
    See common\Utilities.hpp
    #ifdef __REXX64__
    #define CONCURRENCY_TRACE "%16.16x %16.16x %16.16x %5.5hu%c "
    #else
    #define CONCURRENCY_TRACE "%8.8x %8.8x %8.8x %5.5hu%c "
    #endif


    The same format with human-readable ids is also supported :
    T1   A1                   >I> Routine D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
    T1   A1                   >I> Routine A_ROUTINE in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
    T1   A2     V1     1*          >I> Method INIT with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
    T1   A2     V1     1*       44 *-* self~table = .IdentityTable~new
    T2   A0                 Error 99 running D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\trace\doit.rex line 17:  Translation error
    T2   A0                 Error 99.916:  Unrecognized directive instruction

    The classic trace (without any concurrency trace) is also supported.
    That lets generate a CSV file, more easy to analyze/filter.
    Without concurrency trace, it's not possible to get the name of the executable for each line of the CSV file.


Implementation notes:
    traceLineParser = .Tracer.TraceLineParser~new -- you can create a new instance for each line to parse (if you want to keep the attributes), or reuse the same instance (the attributes are reset before parsing)
    currentTrace = traceLineParser~parse(rawLine) -- updates the attributes of traceLineParser and returns an instance of a subclass of Tracer.TraceLine
    currentTrace~lineOut(streamOut, csv, filter)  -- csv: .true or .false, filter: .true or .false


    Attributes of Tracer.TraceLineParser.
    These attributes are analyzed by the class Tracer.TraceLine and its subclasses.
    The parser instantiates the most specialized subclass in function of what have been parsed successfully.
    This subclass analyzes the attributes in its perimeter, and then delegates to its superclass, until reaching the class Tracer.TraceLine.
    ::attribute rawLine                                    ::class Tracer.UnknownFormat
        Specific to concurrency trace
        ::attribute threadId                               ::class Tracer.WithActivationInfo
        ::attribute activationId                           ::class Tracer.WithActivationInfo
        ::attribute varDictId                              ::class Tracer.WithActivationInfo
        ::attribute reserveCount                           ::class Tracer.WithActivationInfo
        ::attribute lock                                   ::class Tracer.WithActivationInfo
        Normal trace line, without concurrency trace
        ::attribute rawTrace                               ::class Tracer.ErrorTrace, ::class Tracer.InvalidTrace
            ::attribute lineNumber                         ::class Tracer.GenericTrace
            ::attribute tracePrefix                        ::class Tracer.GenericTrace
            ::attribute restOfTrace                        ::class Tracer.GenericTrace
                ::attribute routine                        ::class Tracer.RoutineActivation
                ::attribute method                         ::class Tracer.MethodActivation
                ::attribute scope                          ::class Tracer.MethodActivation
                ::attribute package                        ::class Tracer.MethodActivation, ::class Tracer.RoutineActivation


    The parser returns an instance of the most specialized subclass in function of what have been parsed successfully:
    ::class Tracer.TraceLine (abstract)
        ::class Tracer.UnknownFormat
        ::class Tracer.WithActivationInfo
            ::class Tracer.ErrorTrace
            ::class Tracer.InvalidTrace
            ::class Tracer.GenericTrace
                ::class Tracer.RoutineActivation
                ::class Tracer.MethodActivation
                ::class Tracer.UnknownActivation


    Helper classes to manage the task, activation and variable's dictionnary identifiers:
        Tracer.Thread
        Tracer.Activation
        Tracer.VariableDictionary
    Each manages a mapping between hexadecimal pointers and human-readable identifiers.
    Their directories is always growing.
    You can reset their directories by sending the message "init" to each class.


    Output of a reworked trace line.
    Done by the method charout of the most specialized subclass instanciated by the parser.
    This subclass outputs its own attributes, and then delegates to its superclass, until reaching the class Tracer.TraceLine.


    Output of the CSV line.
    Done in three steps with the class Tracer.TraceLineCsv:
    - create an instance of Tracer.TraceLineCsv
    - collect the attributes to display
    - display the attributes
    Attributes of a Tracer.TraceLineCsv.
    They are filled by the method prepareCsv of the most specialized subclass instanciated by the parser.
    This subclass stores its own attributes, and then delegates to its superclass, until reaching the class Tracer.TraceLine.
        ::attribute threadId        .Tracer.Thread~fromId(traceLineParser~threadId)~hrId
        ::attribute activationId    .Tracer.Activation~fromId(traceLineParser~activationId)~hrId
        ::attribute varDictId       .Tracer.VariableDictionary~fromId(traceLineParser~varDictId)~hrId
        ::attribute reserveCount    traceLineParser~reserveCount
        ::attribute lock            traceLineParser~lock
        ::attribute kind            of executable : "method" or "routine"
        ::attribute scope           of executable -- traceLineParser~scope
        ::attribute executable      traceLineParser~method or traceLineParser~routine
        ::attribute line            traceLineParser~lineNumber
        ::attribute prefix          traceLineParser~traceprefix
        ::attribute source          traceLineParser~restOfTrace -- empty when kind, scope, executable and package are provided (because redundant)
        ::attribute package         traceLineParser~package
        ::attribute raw             traceLineParser~rawline or traceLineParser~rawTrace

*/

use arg rexxPackage

-- add all of the public classes to .environment and to the
-- REXX package
publicClasses = .context~package~publicClasses

do name over publicClasses
   class = publicClasses[name]
   --.environment~put(class, name) -- will be done from CoreClasses.orx anyway
   rexxPackage~addPublicClass(name, class)
end

-------------------------------------------------------------------------------
::class Tracer.ConcurrencyTraceOutput public -- was humanizeTraceOutput
-------------------------------------------------------------------------------
::attribute currTraceOutput   -- final destination for edited trace output line
::method init
  expose currTraceOutput traceLineParser
  currTraceOutput=.traceOutput~current    -- get current output
  traceLineParser=.Tracer.TraceLineParser~new
  .traceOutput~destination(self)

::method say
  forward message (lineout)

::method lineout
  expose currTraceOutput traceLineParser
  use arg rawLine

  currentTrace = traceLineParser~parse(rawLine)
  currentTrace~lineOut(currTraceOutput, .false, .false) -- no csv, no filter

::method unknown
  expose currTraceOutput
  forward to (currTraceOutput)   -- unknown method let the original .traceOutput monitor handle it



-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
::class Tracer.Utility public
-------------------------------------------------------------------------------

::method isHex class
    use strict arg str, length
    if str~length <> length then return .false
    return str~verify("0123456789abcdefABCDEF") == 0


::method quoted class
    -- Returns a quoted string.
    -- If the string contains a double quote character, it is escaped by placing another double quote character next to it.
    -- a"bc"d --> "a""bc""d"
    use strict arg string, quote='"'
    doubleQuote = quote || quote
    return quote || string~changeStr(quote, doubleQuote) || quote


::method unquoted class
    -- Replace escaped double quotes by a double quote, and remove leading and trailing double quotes, if any.
    -- "a""bc""d" --> a"bc"d
    use strict arg string, quote='"'
    doubleQuote = quote || quote
    if string~left(1) == quote & string~right(1) == quote then
        return string~substr(2, string~length - 2)~changeStr(doubleQuote, quote)
    else
        return string


-------------------------------------------------------------------------------
::class Tracer.TraceLineParser public
-------------------------------------------------------------------------------

::constant hexIdWidth64bit 16 -- width in digit count of hex id
::constant hexIdWidth32bit 8 -- width in characters of hex id

::attribute rawLine
    -- Specific to concurrency trace
    ::attribute threadId
    ::attribute activationId
    ::attribute varDictId
    ::attribute reserveCount
    ::attribute lock
    -- Normal trace line, without concurrency trace
    ::attribute rawTrace
        ::attribute lineNumber
        ::attribute tracePrefix
        ::attribute restOfTrace
            ::attribute routine
            ::attribute method
            ::attribute scope
            ::attribute package


::method isHexId64bit class
    use strict arg id
    return .Tracer.Utility~isHex(id, .Tracer.TraceLineParser~hexIdWidth64bit) -- Ex : 0001654c0001654c


::method isHexId32bit class
    use strict arg id
    return .Tracer.Utility~isHex(id, .Tracer.TraceLineParser~hexIdWidth32bit) -- Ex : 0001654c


::method init
    rawLine = ""
    threadId = ""
    activationId = ""
    varDictId = ""
    reserveCount = ""
    lock = ""
    rawTrace = ""
    lineNumber = ""
    tracePrefix = ""
    restOfTrace = ""
    routine = ""
    method = ""
    scope = ""
    package = ""


::method parse64bit
    use strict arg -- none
    parse value self~rawLine with,
            1 self~threadId >(.Tracer.TraceLineParser~hexIdWidth64bit),
            +1 self~activationId >(.Tracer.TraceLineParser~hexIdWidth64bit),
            +1 self~varDictId >(.Tracer.TraceLineParser~hexIdWidth64bit),
            +1 self~reserveCount >(.Tracer.WithActivationInfo~reserveCountRawWidth) self~lock >1,
            +1 self~rawTrace
    return  .Tracer.TraceLineParser~isHexId64bit(self~threadId) &,
            .Tracer.TraceLineParser~isHexId64bit(self~activationId) &,
            .Tracer.TraceLineParser~isHexId64bit(self~varDictId) &,
            self~reserveCount~datatype("W") &,
            (self~lock == " " | self~lock == "*")


::method parse32bit
    use strict arg -- none
    parse value self~rawLine with,
            1 self~threadId >(.Tracer.TraceLineParser~hexIdWidth32bit),
            +1 self~activationId >(.Tracer.TraceLineParser~hexIdWidth32bit),
            +1 self~varDictId >(.Tracer.TraceLineParser~hexIdWidth32bit),
            +1 self~reserveCount >(.Tracer.WithActivationInfo~reserveCountRawWidth) self~lock >1,
            +1 self~rawTrace
    return  .Tracer.TraceLineParser~isHexId32bit(self~threadId) &,
            .Tracer.TraceLineParser~isHexId32bit(self~activationId) &,
            .Tracer.TraceLineParser~isHexId32bit(self~varDictId) &,
            self~reserveCount~datatype("W") &,
            (self~lock == " " | self~lock == "*")


::method parseHrId
    use strict arg -- none
    parse value self~rawLine with,
            1 self~threadId >(.Tracer.Thread~hrIdWidth),
            +1 self~activationId >(.Tracer.Activation~hrIdWidth),
            +1 self~varDictId >(.Tracer.VariableDictionary~hrIdWidth),
            +1 self~reserveCount >(.Tracer.WithActivationInfo~reserveCountHrWidth) self~lock >1,
            +1 self~rawTrace
    return  .Tracer.Thread~isHrId(self~threadId) &,
            .Tracer.Activation~isHrId(self~activationId) &,
            .Tracer.VariableDictionary~isHrId(self~varDictId) &,
            (self~reserveCount~datatype("W") | self~reserveCount~strip == "") &,
            (self~lock == " " | self~lock == "*")


::method clearConcurrencyTrace
    -- The various parsings have stored some invalid values, clear them
    use strict arg -- none
    self~threadId = ""
    self~activationId = ""
    self~varDictId = ""
    self~reserveCount = ""
    self~lock = ""
    self~rawTrace = self~rawLine


::method parse
    use strict arg rawLine
    self~init
    self~rawLine = rawLine
    currentTrace = .nil

    -- Several concurrency trace formats supported
    concurrencyTrace = "none"
    if self~parse64bit then concurrencyTrace = 64 -- 64-bit pointers
    else if self~parse32bit then concurrencyTrace = 32 -- 32-bit pointers
    else if self~parseHrId then concurrencyTrace = "hr" -- hr ids (parsing a trace already hr-ized)
    else self~clearConcurrencyTrace

    if self~rawTrace~pos("Error") == 1 then currentTrace = .Tracer.ErrorTrace~new
    else do -- maybe normal trace line
        parse value self~rawTrace with 1 self~lineNumber >6 +1 self~tracePrefix >3 +1 self~restOfTrace
        valid = .Tracer.TraceLine~isValidLineNumber(self~lineNumber) &,
                .Tracer.TraceLine~isValidPrefix(self~tracePrefix)
        if \valid then do
            if concurrencyTrace == "none" then currentTrace = .Tracer.UnknownFormat~new
            else currentTrace = .Tracer.InvalidTrace~new
        end
        else do -- valid trace line
            if self~tracePrefix == ">I>" then do
                if self~restOfTrace~pos("Routine ") == 1 then do
                    currentTrace = .Tracer.RoutineActivation~new
                    parse value self~restOfTrace with "Routine " self~routine " in package " self~package
                end
                else if self~restOfTrace~pos("Method ") == 1 then do
                    currentTrace = .Tracer.MethodActivation~new
                    parse value self~restOfTrace with "Method " self~method ' with scope "' self~scope '" in package ' self~package
                end
                else currentTrace = .Tracer.UnknownActivation~new
            end
            else currentTrace = .Tracer.GenericTrace~new
        end
    end

    currentTrace~initializeWith(self)
    return currentTrace


-------------------------------------------------------------------------------
::class Tracer.TraceLineCsv public
-------------------------------------------------------------------------------
-- Helper to generate a CSV line

::constant sep ","

-- Better to have a non-empty value, otherwise filtering may not be good (depending on your favorite tool)
::constant defaultValue "."


::method lineoutTitle class
    use strict arg stream
    stream~charout("thread") ; stream~charout(self~sep)
    stream~charout("activation") ; stream~charout(self~sep)
    stream~charout("varDict") ; stream~charout(self~sep)
    stream~charout("count") ; stream~charout(self~sep)
    stream~charout("lock") ; stream~charout(self~sep)
    stream~charout("kind") ; stream~charout(self~sep)
    stream~charout("scope") ; stream~charout(self~sep)
    stream~charout("executable") ; stream~charout(self~sep)
    stream~charout("line") ; stream~charout(self~sep)
    stream~charout("prefix") ; stream~charout(self~sep)
    stream~charout("source") ; stream~charout(self~sep)
    stream~charout("package") ; stream~charout(self~sep)
    stream~charout("raw") -- ; stream~charout(self~sep)
    stream~lineout("")


::attribute threadId
::attribute activationId
::attribute varDictId
::attribute reserveCount
::attribute lock
::attribute kind -- of executable
::attribute scope -- of executable
::attribute executable
::attribute line
::attribute prefix
::attribute source
::attribute package
::attribute raw


::method init
    self~threadId = ""
    self~activationId = ""
    self~varDictId = ""
    self~reserveCount = ""
    self~lock = ""
    self~kind = ""
    self~scope = ""
    self~executable = ""
    self~line = ""
    self~prefix = ""
    self~source = ""
    self~package = ""
    self~raw = ""


::method quoted
    use strict arg value
    value = value~strip
    if value == "" then value = self~defaultValue
    return .Tracer.Utility~quoted(value)


::method charout
    use strict arg stream, value
    stream~charout(self~quoted(value))
    stream~charout(self~sep)


::method lineout
    use strict arg stream
    self~charout(stream, self~threadId)
    self~charout(stream, self~activationId)
    self~charout(stream, self~varDictId)
    self~charout(stream, self~reserveCount)
    self~charout(stream, self~lock)
    self~charout(stream, self~kind)
    self~charout(stream, self~scope)
    self~charout(stream, self~executable)
    self~charout(stream, self~line)
    self~charout(stream, self~prefix)
    self~charout(stream, self~source)
    self~charout(stream, self~package)
    self~charout(stream, self~raw)
    stream~lineout("")


-------------------------------------------------------------------------------
::class Tracer.Thread public
-------------------------------------------------------------------------------

::constant hrIdWidth 4 -- width of hr id (used for parsing and rewriting)


-- class attributes
::attribute counter class
::attribute directory class


::method init class
    self~counter = 0
    self~directory = .directory~new


::method fromId class
    use strict arg threadId
    thread = .Tracer.Thread~directory[threadId]
    if .nil == thread then do
        thread = .Tracer.Thread~new
        .Tracer.Thread~directory[threadId] = thread
        thread~id = threadId
        if threadId == "" then thread~hrId = ""
        else if threadId = 0 | threadId == "T0" then thread~hrId = "T0" -- Always use T0 for null pointer
        else do
            .Tracer.Thread~counter += 1
            thread~hrId = "T".Tracer.Thread~counter
        end
    end
    return thread


::method isHrId class
    use strict arg threadId
    return threadId~left(1) =="T" & threadId~substr(2)~dataType("W")  -- Ex : T1, T12, T123, ...


-- instance attributes
::attribute id
::attribute hrId -- Human-readable


::method init
    self~id = ""
    self~hrId = ""


-------------------------------------------------------------------------------
::class Tracer.Activation public
-------------------------------------------------------------------------------

::constant hrIdWidth 6 -- max width of hr id (used for parsing and rewriting)


-- class attributes
::attribute counter class
::attribute directory class


::method init class
    self~counter = 0
    self~directory = .directory~new


-- Human-readable activation id
::method fromId class
    use strict arg activationId
    activation = .Tracer.Activation~directory[activationId]
    if .nil == activation then do
        activation = .Tracer.Activation~new
        .Tracer.Activation~directory[activationId] = activation
        activation~id = activationId
        if activationId == "" then activation~hrId = ""
        else if activationId = 0 | activationId == "A0" then activation~hrId = "A0" -- Always use A0 for null pointer
        else do
            .Tracer.Activation~counter += 1
            activation~hrId = "A".Tracer.Activation~counter
        end
    end
    return activation


::method isHrId class
    use strict arg activationId
    return activationId~left(1) =="A" & activationId~substr(2)~dataType("W")  -- Ex : A1, A12, A123, ...

-- instance attributes
::attribute id
::attribute hrId -- Human-readable
::attribute kind
::attribute scope
::attribute executable
::attribute package


::method init
    self~id = ""
    self~hrId = ""
    self~kind = ""
    self~scope = ""
    self~executable = ""
    self~package = ""


-------------------------------------------------------------------------------
::class Tracer.VariableDictionary public
-------------------------------------------------------------------------------

::constant hrIdWidth 6 -- max width of hr id (used for parsing and rewriting)


-- class attributes
::attribute counter class
::attribute directory class


::method init class
    self~counter = 0
    self~directory = .directory~new


-- Human-readable varDict id
::method fromId class
    use strict arg varDictId -- can be made of spaces, when parsing hr trace
    varDict = .Tracer.VariableDictionary~directory[varDictId]
    if .nil == varDict then do
        varDict = .Tracer.VariableDictionary~new
        .Tracer.VariableDictionary~directory[varDictId] = varDict
        varDict~id = varDictId
        if varDictId == "" then varDict~hrId = ""
        else if varDictId = 0 | varDictId == "V0" | varDictId = "" then varDict~hrId = "V0" -- Always use V0 for null pointer
        else do
            .Tracer.VariableDictionary~counter += 1
            varDict~hrId = "V".Tracer.VariableDictionary~counter
        end
    end
    return varDict


::method isHrId class
    use strict arg varDictId
    if varDictId = "" then return .true -- special case, when parsing hr trace.
    return varDictId~left(1) =="V" & varDictId~substr(2)~dataType("W")  -- Ex : V1, V12, V123, ...

-- instance attributes
::attribute id
::attribute hrId -- Human-readable


::method init
    self~id = ""
    self~hrId = ""


-------------------------------------------------------------------------------
::class Tracer.TraceLine public abstract
-------------------------------------------------------------------------------
-- TraceLine
--    UnknownFormat
--    WithActivationInfo
--        ErrorTrace
--        InvalidTrace
--        GenericTrace
--            RoutineActivation
--            MethodActivation
--            UnknownActivation


::method isValidLineNumber class
    use strict arg lineNumber
    return lineNumber~datatype("W") | lineNumber~strip == ""


::method isValidPrefix class
    use strict arg prefix
    -- The last "..." is not a standard trace prefix. This is the prefix used by the debug output of SysSemaphore and SysMutex.
    -- New ooRexx5: >K> <R>
    -- Collision: >N> is named argument for executor, namespace for ooRexx5
    return prefix~space(0)~length == 3 & "*-* +++ >I> >>> >=> >.> >A> >C> >E> >F> >L> >M> >N> >O> >P> >V> >K> >R> ..."~pos(prefix) <> 0


::method initializeWith
    use strict arg _traceLineParser
    return


::method lineout
    use strict arg stream, csv, filter
    if csv then do
        csv = .Tracer.TraceLineCsv~new
        if self~prepareCsv(csv, filter) then csv~lineout(stream)
    end
    else do
        if self~charout(stream, filter) then stream~lineOut("")
    end


::method charout
    use strict arg stream, _filter
    return .false -- nothing displayed here


::method prepareCsv
    use strict arg _csv, _filter
    return .false -- nothing stored here


-------------------------------------------------------------------------------
::class Tracer.UnknownFormat subclass Tracer.TraceLine public
-------------------------------------------------------------------------------

::attribute rawLine


::method initializeWith
    use strict arg traceLineParser
    self~rawLine = traceLineParser~rawline
    forward class (super)


::method charout
    use strict arg stream, filter
    if filter then return .false
    forward class (super) continue
    if result == .true then stream~charout(" ")
    -- Unknown structure : print as-is
    stream~charout(self~rawLine)
    return .true


::method prepareCsv
    use strict arg csv, filter
    if filter then return .false
    forward class (super) continue
    -- Unknown structure : put all in 'raw' column
    csv~raw = self~rawLine
    return .true


-------------------------------------------------------------------------------
::class Tracer.WithActivationInfo subclass Tracer.TraceLine public
-------------------------------------------------------------------------------

::constant reserveCountRawWidth 5 -- unsigned short : 0...65535 : 5 digits
::constant reserveCountHrWidth 2 -- in practice, I don't think we go above 99 : 2 digits


::attribute threadId
::attribute activationId
::attribute varDictId
::attribute reserveCount
::attribute lock


::method initializeWith
    use strict arg traceLineParser
    self~threadId = traceLineParser~threadId
    self~activationId = traceLineParser~activationId
    self~varDictId = traceLineParser~varDictId
    self~reserveCount = traceLineParser~reserveCount
    self~lock = traceLineParser~lock
    forward class (super)


::method noConcurrencyTrace
    return self~threadId == "",
         & self~activationId == "",
         & self~varDictId == "",
         & self~reserveCount == "",
         & self~lock == ""


::method charout
    use strict arg stream, _filter

    forward class (super) continue
    spaceNeeded = result

    if self~noConcurrencyTrace then return .false

    thread = .Tracer.Thread~fromId(self~threadId)
    activation = .Tracer.Activation~fromId(self~activationId)

    varDict = .Tracer.VariableDictionary~fromId(self~varDictId)
    varDictHrId = varDict~hrId
    if varDictHrId == "V0" then varDictHrId = ""

    reserveCount = self~reserveCount
    if reserveCount = 0 then reserveCount = ""
    if reserveCount <> "" then reserveCount = reserveCount~format(.Tracer.WithActivationInfo~reserveCountHrWidth)

    if spaceNeeded then stream~charout(" ")
    stream~charout(thread~hrId~left(.Tracer.Thread~hrIdWidth),
                   activation~hrId~left(.Tracer.Activation~hrIdWidth),
                   varDictHrId~left(.Tracer.VariableDictionary~hrIdWidth),
                   reserveCount~left(.Tracer.WithActivationInfo~reserveCountHrWidth) || self~lock)
    return .true


::method prepareCsv
    use strict arg csv, _filter
    forward class (super) continue
    if self~noConcurrencyTrace then return .false

    thread = .Tracer.Thread~fromId(self~threadId)
    csv~threadId = thread~hrId

    activation = .Tracer.Activation~fromId(self~activationId)
    csv~activationId = activation~hrId

    varDict = .Tracer.VariableDictionary~fromId(self~varDictId)
    if varDict~hrId <> "V0" then csv~varDictId = varDict~hrId

    if self~reserveCount <> 0 then csv~reserveCount = self~reserveCount
    csv~lock = self~lock
    csv~kind = activation~kind
    csv~scope = activation~scope
    csv~executable = activation~executable
    csv~package = activation~package
    return .true


-------------------------------------------------------------------------------
::class Tracer.ErrorTrace subclass Tracer.WithActivationInfo public
-------------------------------------------------------------------------------

::attribute rawTrace


::method initializeWith
    use strict arg traceLineParser
    self~rawTrace = traceLineParser~rawTrace
    forward class (super)


::method charout
    use strict arg stream, _filter
    forward class (super) continue
    if result == .true then stream~charout(" ")
    stream~charout(self~rawTrace)
    return .true


::method prepareCsv
    use strict arg csv, _filter
    forward class (super) continue
    csv~raw = self~rawTrace
    return .true


-------------------------------------------------------------------------------
::class Tracer.InvalidTrace subclass Tracer.WithActivationInfo public
-------------------------------------------------------------------------------

::attribute rawTrace


::method initializeWith
    use strict arg traceLineParser
    self~rawTrace = traceLineParser~rawTrace
    forward class (super)


::method charout
    use strict arg stream, filter
    if filter then return .false
    forward class (super) continue
    if result == .true then stream~charout(" ")
    stream~charout(self~rawTrace)
    return .true


::method prepareCsv
    use strict arg csv, filter
    if filter then return .false
    forward class (super) continue
    csv~raw = self~rawTrace
    return .true


-------------------------------------------------------------------------------
::class Tracer.GenericTrace subclass Tracer.WithActivationInfo public
-------------------------------------------------------------------------------

::attribute lineNumber
::attribute tracePrefix
::attribute restOfTrace


::method initializeWith
    use strict arg traceLineParser
    self~lineNumber = traceLineParser~lineNumber
    self~traceprefix = traceLineParser~traceprefix
    self~restOfTrace = traceLineParser~restOfTrace
    forward class (super)


::method charout
    use strict arg stream, _filter
    forward class (super) continue
    if result == .true then stream~charout(" ")
    stream~charout(self~lineNumber,
                   self~tracePrefix,
                   self~restOfTrace)
    return .true


::method prepareCsv
    use strict arg csv, _filter
    forward class (super) continue
    csv~line = self~lineNumber
    csv~prefix = self~tracePrefix
    csv~source = self~restOfTrace
    return .true


-------------------------------------------------------------------------------
::class Tracer.RoutineActivation subclass Tracer.GenericTrace public
-------------------------------------------------------------------------------

::attribute routine
::attribute package


::method initializeWith
    use strict arg traceLineParser
    self~routine = traceLineParser~routine
    self~package = traceLineParser~package
    forward class (super) continue

    if self~noConcurrencyTrace then return

    -- Stores other infos of the activation's trace on the activation, for use in following trace lines
    activation = .Tracer.Activation~fromId(self~activationId)
    activation~kind = "routine"
    activation~scope = ""
    activation~executable = self~routine
    activation~package = self~package


::method prepareCsv
    use strict arg csv, _filter
    forward class (super) continue

    csv~source = "" -- self~restOfTrace -- redundant with kind, executable, package.

    -- The superclass WithActivationInfo manages the following attributes,
    -- but only when the concurrency trace is available.
    -- Here we can store these values even when no concurrency trace (they come from >I> trace)
    -- but this is ONLY for the current trace line, not for the next trace lines.
    csv~kind = "routine"
    csv~executable = self~routine
    csv~package = self~package
    return .true


-------------------------------------------------------------------------------
::class Tracer.MethodActivation subclass Tracer.GenericTrace public
-------------------------------------------------------------------------------

::attribute method
::attribute scope
::attribute package


::method initializeWith
    use strict arg traceLineParser
    self~method = traceLineParser~method
    self~scope = traceLineParser~scope
    self~package = traceLineParser~package
    forward class (super) continue

    -- Stores other infos of the activation's trace on the activation, for use in following trace lines
    activation = .Tracer.Activation~fromId(self~activationId)
    activation~kind = "method"
    activation~scope = self~scope
    activation~executable = self~method
    activation~package = self~package


::method prepareCsv
    use strict arg csv, _filter
    forward class (super) continue

    csv~source = "" -- self~restOfTrace -- redundant with kind, scope, executable, package.

    -- The superclass WithActivationInfo manages the following attributes,
    -- but only when the concurrency trace is available.
    -- Here we can store these values even when no concurrency trace (they come from >I> trace)
    -- but this is ONLY for the current trace line, not for the next trace lines.
    csv~kind = "method"
    csv~scope = self~scope
    csv~executable = self~method
    csv~package = self~package
    return .true


-------------------------------------------------------------------------------
::class Tracer.UnknownActivation subclass Tracer.GenericTrace public
-------------------------------------------------------------------------------


